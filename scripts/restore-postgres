#!/usr/bin/env bash

# *This file is meant to be run as root or with sudo*
# It will restore the Postgres database from a backup file

# confirm that user is root or sudo, if not exit
if [ "$EUID" -ne 0 ]
  then echo "Please run as root or with sudo"
  exit
fi

# Get the directory of the script
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
# Get the dir 1 level up
DIR="$(dirname "$DIR")"

# Load the environment variables
source "$DIR/.env"

REQUIRED_VARS=(
  LOCAL_BACKUP_PATH
  LOCAL_POSTGRES_BACKUP_PATH
  LOGS_PATH
)

for var in "${REQUIRED_VARS[@]}"; do
  if [ -z "${!var}" ] || [ "${!var}" = "REPLACE_ME" ]; then
    echo "$var is unset. Please set this in your .env file." 
    exit 1
  fi
done

# log file + backup path
LOG_FILE="${LOGS_PATH}plausible-restore-postgres.log"
BACKUP_PATH=${LOCAL_BACKUP_PATH}${LOCAL_POSTGRES_BACKUP_PATH}

# function to log messages
log_message() {
  local log_dir=$(dirname "$LOG_FILE")
  local log_file=$(basename "$LOG_FILE")
  local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
  local message="${1//[$'\n']/}" # Remove newline characters from the message
  local level="${2:-INFO}" # Optional log level

  # Create the log directory if it doesn't exist
  if [ ! -d "$log_dir" ]; then
    mkdir -p "$log_dir"
  fi

  # Create the log file if it doesn't exist
  if [ ! -f "$LOG_FILE" ]; then
    touch "$LOG_FILE"
  fi

  echo "$timestamp - [$level] $message" >> "$LOG_FILE"
}

# Define the container name
# Look for POSTGRES_CONTAINER_NAME and set to default if not found
if [ -z ${POSTGRES_CONTAINER_NAME+x} ]; then
    POSTGRES_CONTAINER_NAME="analytics-plausible_db-1"
fi

CONTAINER_NAME=${POSTGRES_CONTAINER_NAME}

# Check if backup file is provided as argument
if [ -z "$1" ]; then
    # No argument provided, list available backups and prompt user
    echo "Available PostgreSQL backups in ${BACKUP_PATH}:"
    echo "----------------------------------------"
    ls -lh ${BACKUP_PATH}*.tar 2>/dev/null | awk '{print $9, "(" $5 ")"}'
    
    if [ $? -ne 0 ] || [ -z "$(ls -A ${BACKUP_PATH}*.tar 2>/dev/null)" ]; then
        echo "No backup files found in ${BACKUP_PATH}"
        log_message "No backup files found in ${BACKUP_PATH}" "ERROR"
        exit 1
    fi
    
    echo ""
    echo "Usage: $0 <backup_file>"
    echo "Example: $0 ${BACKUP_PATH}plausible_db_backup_2024-01-15-10-30-00.tar"
    exit 1
fi

BACKUP_FILE="$1"

# Validate backup file exists
if [ ! -f "$BACKUP_FILE" ]; then
    echo "Backup file not found: $BACKUP_FILE"
    log_message "Backup file not found: $BACKUP_FILE" "ERROR"
    exit 1
fi

# Extract just the filename for logging
BACKUP_FILENAME=$(basename "$BACKUP_FILE")

log_message "Starting restore of PostgreSQL database from backup: $BACKUP_FILENAME"

# Confirmation prompt
echo "⚠️  WARNING: This will restore the Plausible PostgreSQL database from backup."
echo "Database: plausible_db"
echo "Backup file: $BACKUP_FILENAME"
echo ""
read -p "Are you sure you want to proceed? (yes/no): " CONFIRM

if [ "$CONFIRM" != "yes" ]; then
    echo "Restore cancelled by user."
    log_message "Restore cancelled by user." "INFO"
    exit 0
fi

# Copy the backup file into the Docker container
log_message "Copying backup file $BACKUP_FILENAME to Docker container."
docker exec $CONTAINER_NAME /bin/bash -c "mkdir -p /var/lib/postgresql/restores/"
docker cp "$BACKUP_FILE" $CONTAINER_NAME:/var/lib/postgresql/restores/restore.tar

if [ $? -ne 0 ]; then
    log_message "Failed to copy backup file to container." "ERROR"
    echo "Failed to copy backup file to container."
    exit 1
fi

# Revoke connect privileges and terminate existing connections
log_message "Revoking connection privileges and terminating existing connections to plausible_db."
docker exec $CONTAINER_NAME /bin/bash -c "PGPASSWORD=postgres psql -h localhost -p 5432 -U postgres -d postgres <<EOF
-- Revoke connection privileges
REVOKE CONNECT ON DATABASE plausible_db FROM public;
ALTER DATABASE plausible_db ALLOW_CONNECTIONS false;

-- Terminate all connections
SELECT pg_terminate_backend(pg_stat_activity.pid)
FROM pg_stat_activity
WHERE pg_stat_activity.datname = 'plausible_db'
  AND pid <> pg_backend_pid();
EOF
"

# Small delay to ensure connections are fully terminated
sleep 2

# Drop the existing database
log_message "Dropping existing plausible_db database."
docker exec $CONTAINER_NAME /bin/bash -c "PGPASSWORD=postgres psql -h localhost -p 5432 -U postgres -d postgres -c 'DROP DATABASE IF EXISTS plausible_db;'"

if [ $? -ne 0 ]; then
    log_message "Failed to drop database." "ERROR"
    echo "Failed to drop database."
    exit 1
fi

# Recreate the database
log_message "Creating new plausible_db database."
docker exec $CONTAINER_NAME /bin/bash -c "PGPASSWORD=postgres psql -h localhost -p 5432 -U postgres -d postgres -c 'CREATE DATABASE plausible_db;'"

if [ $? -ne 0 ]; then
    log_message "Failed to create database." "ERROR"
    echo "Failed to create database."
    exit 1
fi

# Restore from the backup file
log_message "Restoring database from backup file."
docker exec $CONTAINER_NAME /bin/bash -c "PGPASSWORD=postgres pg_restore -h localhost -p 5432 -U postgres -d plausible_db -v /var/lib/postgresql/restores/restore.tar"

if [ $? -ne 0 ]; then
    log_message "Failed to restore database from backup." "ERROR"
    echo "Failed to restore database from backup."
    exit 1
fi

# Clean up the restore file from inside the Docker container
log_message "Removing restore file from Docker container."
docker exec $CONTAINER_NAME /bin/bash -c "rm /var/lib/postgresql/restores/restore.tar"

# Check for success
if [ $? -eq 0 ]; then
    log_message "Successfully restored the Plausible PostgreSQL database from $BACKUP_FILENAME."
    echo "✅ Successfully restored the Plausible PostgreSQL database from $BACKUP_FILENAME."
else
    log_message "Failed to restore the Plausible PostgreSQL database." "ERROR"
    echo "❌ Failed to restore the Plausible PostgreSQL database."
    exit 1
fi
